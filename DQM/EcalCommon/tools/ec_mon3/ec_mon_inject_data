#!/usr/bin/env perl

use strict "vars";
use vars qw( %opts );
use vars qw( %config );

use Getopt::Long;

Getopt::Long::config('bundling_override');
%opts = ();
GetOptions( \%opts,
                "debug|d",
                "verbose|v",
                "norun",
                "check",
                "cleanup",
                "renotify",
                "now",
                "help|h"
);
usage() if ( $opts{'help'} || $Getopt::Long::error );

#time after which to inject the data file
my $inject_timeout = 10 * 60; #10 minutes in secs

$inject_timeout = 0 if ( $opts{'now'} );

#time after which to remove a 'failed' run
my $remove_timeout = 6 * 60 * 60; #6 hours in secs

$remove_timeout = 0 if ( $opts{'now'} );

my $path = "/dropbox/ecal/daq-data";

exit 1 if ( -e "$path/.ec_mon_inject_data.lock" );

system("touch $path/.ec_mon_inject_data.lock");

my $verbose = "";
$verbose = "--debug" if ( $opts{'verbose'} );

my $renotify = "";
$renotify = "--renotify" if ( $opts{'renotify'} );

my $file;

my @files = split('\n', `find $path/ -maxdepth 1 -name 'ecal_local.*.dat' -printf '%f\n' 2>&1 | sort`);

foreach $file ( @files ) {

  $file =~ s/.dat//;

  if ( -e "$path/$file.log" ) {

    print "Found inject data log file $path/$file.log\n" if ( $opts{'debug'} );

    if ( $opts{'check'} || $opts{'cleanup'} ) {

      my $command = "/nfshome0/tier0/scripts/injectFileIntoTransferSystem.pl $verbose --config /nfshome0/ecalpro/DQM/.dbs.conf --check --filename $file.dat";

      print "$command\n" if ( $opts{'debug'} );

      if ( ! system("$command 2>&1 | grep -q 'FILES_TRANS_CHECKED: File found in database and checked by T0 system.'") ) {

        print " - File $file.dat found in database and checked by T0 system.\n" if ( $opts{'check'} || $opts{'debug'} );

        if ( $opts{'cleanup'} ) {

          my $update = (stat("$path/$file.dat"))[9];
          my $time = ((( time() - $update ) / 60.) / 60.);

          printf "Last updated %.1f hours ago\n", $time if ( $opts{'debug'} );

          if ( ( time() - $update ) > $remove_timeout ) {

            print "Removing $file.dat: " if ( $opts{'debug'} );

            my $status = 0;
            $status = system("rm -f $path/$file.dat") unless ( $opts{'norun'} );
            if ( ! $status ) {
              print "done\n" if ( $opts{'debug'} );
            } else {
              print "failed\n" if ( $opts{'debug'} );
            }

          }

        }

      } else {

        print " - File $file.dat not yet checked by T0 system.\n" if ( $opts{'check'} || $opts{'debug'} );

      }

    }

  } else {

    next if ( $opts{'check'} );

    print "Inject data file for $path/$file.dat not found !!!\n" if ( $opts{'debug'} );

    my $update = (stat("$path/$file.dat"))[9];
    my $time = ((( time() - $update ) / 60.) / 60.);

    printf "$path/$file.dat was last updated %.1f hours ago\n", $time if ( $opts{'debug'} );

    if ( ( time() - $update ) > $inject_timeout ) {
      print "Creating inject data log file $path/$file.log : " if ( $opts{'debug'} );

      my $filesize = -s "$path/$file.dat";

      my ($loc, $num, $lun, $out, $fun, $fil, $ful) = split('\.', "$file.dat");

      my @data0 = split(' ', read_db("P5_Co", $num));

      my $ctime = (stat("$path/$file.dat"))[9];
      $ctime = $data0[1] if ( defined($data0[1]) );
      my $itime = time();

      my @data1 = split('\.', $file);

      my $runnumber = $data1[1];
      my $lumisection = $data1[2];
      my $counter = $data1[6];

      my $nevents = 0;
      $nevents = $data0[3] if ( defined($data0[3]) );
      if ( $nevents == "0" ) {
        $nevents = $data0[4] if ( defined($data0[4]) );
      }

      my $type = "streamer";

      my $appname = "CMSSW";

#      my $appversion = "CMSSW_1_8_0";
#      my $setuplabel = "Commissioning2008Ecal";

#      my $appversion = "CMSSW_2_1_4";
#      my $setuplabel = "Commissioning2008Ecal";

#      my $appversion = "CMSSW_2_1_9";
#      my $setuplabel = "PrivEcal219";

#      my $appversion = "CMSSW_3_3_0";
#      my $setuplabel = "PrivEcal330";

      my $appversion = "CMSSW_5_0_1";
      my $setuplabel = "PrivEcal501";

      my $stream = "A";
      my $producer = "ECAL_LOCAL_DAQ";

      my $command = "/nfshome0/tier0/scripts/injectFileIntoTransferSystem.pl $verbose $renotify --config /nfshome0/ecalpro/DQM/.dbs.conf --path $path --filename $file.dat --filesize $filesize --ctime $ctime --itime $itime --type $type --runnumber $runnumber --lumisection $lumisection --count $counter --nevents $nevents --setuplabel $setuplabel --stream $stream --appname $appname --appversion $appversion --producer $producer";

      print "Injecting $path/$file.dat\n";

      print "$command\n" if ( $opts{'debug'} );

      if ( ! $opts{'norun'} ) {

        open FILE, ">$path/$file.log";
        print FILE "$command\n";
        close FILE;

        if ( ! system("$command >> $path/$file.log 2>&1") ) {
          print "done !!!\n" if ( $opts{'debug'} );
        } else {
          print "failed !!!\n" if ( $opts{'debug'} );
        }

      }

    }

  }

}


@files = split('\n', `find $path/ -maxdepth 1 -name 'ecal_local.*.log' -printf '%f\n' 2>&1 | sort`);

foreach $file ( @files ) {

  $file =~ s/.log//;

  if ( ! -e "$path/$file.dat" ) {

    print "Archiving inject data log file $path/$file.log to $path/logs/\n" if ( $opts{'debug'} );

    system("mv $path/$file.log $path/logs/ >> /dev/null 2>&1");

  }

}

system("rm $path/.ec_mon_inject_data.lock");

exit 0;

############################################################################

sub read_db {

use warnings;
use strict;

use DBI;
use DBD::Oracle qw(:ora_types);

my ($site,$run) = @_;

$ENV{"NLS_LANG"} = "AMERICAN";

my $dsn = "DBI:Oracle:cms_tstore";

my $dbh = DBI->connect($dsn, 'cms_ecal_r', '3c4l_r34d3r');

my $sql = qq[ SELECT riov.run_num run,
                     CAST((riov.run_start-TO_DATE('1970-01-01 00:00:00','YYYY-MM-DD HH24:MI:SS'))/(1/86400) AS INTEGER) run_start,
                     CAST((riov.run_end-TO_DATE('1970-01-01 00:00:00','YYYY-MM-DD HH24:MI:SS'))/(1/86400) AS INTEGER) run_end,
                     rdat.num_events runevt,
                     mdat.num_events monevt
                FROM run_iov riov
                JOIN run_tag rtag ON rtag.tag_id = riov.tag_id
                JOIN location_def ldef ON ldef.def_id = rtag.location_id
                LEFT OUTER JOIN run_dat rdat ON rdat.iov_id = riov.iov_id
                JOIN mon_run_iov miov ON miov.run_iov_id = riov.iov_id
                JOIN mon_run_dat mdat ON mdat.iov_id = miov.iov_id
               WHERE ldef.location = ?
                 AND riov.run_num = ?
            ORDER BY run];

my $sth = $dbh->prepare_cached($sql);

$sth->execute($site,$run);

my @row = $sth->fetchrow();
@row = map { defined $_ ? $_ : "" } @row;

$sth->finish();

$dbh->disconnect();

return join(" ", @row);

}

############################################################################

sub usage {

        print STDERR <<INLINE_LITERAL_TEXT;
usage: ec_mon_inject_data [options]

Options are:
  --norun  Do not create the inject data files, just list what would be done

  --debug
INLINE_LITERAL_TEXT

        exit;
}

############################################################################

