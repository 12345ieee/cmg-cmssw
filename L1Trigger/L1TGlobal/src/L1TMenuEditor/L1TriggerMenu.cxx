// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <L1Trigger/L1TGlobal/src/L1TMenuEditor/xsd/cxx/pre.hxx>

#include "L1Trigger/L1TGlobal/src/L1TMenuEditor/L1TriggerMenu.hxx"

namespace l1t
{
  // DateTime
  // 


  // Label
  // 


  // Description
  // 


  // MenuName
  // 


  // ScalesKey
  // 


  // FirmwareVersion
  // 


  // History
  // 

  const History::revision_sequence& History::
  revision () const
  {
    return this->revision_;
  }

  History::revision_sequence& History::
  revision ()
  {
    return this->revision_;
  }

  void History::
  revision (const revision_sequence& s)
  {
    this->revision_ = s;
  }


  // Revision
  // 

  const Revision::author_type& Revision::
  author () const
  {
    return this->author_.get ();
  }

  Revision::author_type& Revision::
  author ()
  {
    return this->author_.get ();
  }

  void Revision::
  author (const author_type& x)
  {
    this->author_.set (x);
  }

  void Revision::
  author (::std::auto_ptr< author_type > x)
  {
    this->author_.set (x);
  }

  const Revision::datetime_type& Revision::
  datetime () const
  {
    return this->datetime_.get ();
  }

  Revision::datetime_type& Revision::
  datetime ()
  {
    return this->datetime_.get ();
  }

  void Revision::
  datetime (const datetime_type& x)
  {
    this->datetime_.set (x);
  }

  void Revision::
  datetime (::std::auto_ptr< datetime_type > x)
  {
    this->datetime_.set (x);
  }

  const Revision::username_optional& Revision::
  username () const
  {
    return this->username_;
  }

  Revision::username_optional& Revision::
  username ()
  {
    return this->username_;
  }

  void Revision::
  username (const username_type& x)
  {
    this->username_.set (x);
  }

  void Revision::
  username (const username_optional& x)
  {
    this->username_ = x;
  }

  void Revision::
  username (::std::auto_ptr< username_type > x)
  {
    this->username_.set (x);
  }

  const Revision::hostname_optional& Revision::
  hostname () const
  {
    return this->hostname_;
  }

  Revision::hostname_optional& Revision::
  hostname ()
  {
    return this->hostname_;
  }

  void Revision::
  hostname (const hostname_type& x)
  {
    this->hostname_.set (x);
  }

  void Revision::
  hostname (const hostname_optional& x)
  {
    this->hostname_ = x;
  }

  void Revision::
  hostname (::std::auto_ptr< hostname_type > x)
  {
    this->hostname_.set (x);
  }


  // ConditionEtComparison
  // 

  ConditionEtComparison::
  ConditionEtComparison (value v)
  : ::xml_schema::string (_xsd_ConditionEtComparison_literals_[v])
  {
  }

  ConditionEtComparison::
  ConditionEtComparison (const char* v)
  : ::xml_schema::string (v)
  {
  }

  ConditionEtComparison::
  ConditionEtComparison (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  ConditionEtComparison::
  ConditionEtComparison (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  ConditionEtComparison::
  ConditionEtComparison (const ConditionEtComparison& v,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  ConditionEtComparison& ConditionEtComparison::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_ConditionEtComparison_literals_[v]);

    return *this;
  }


  // RelativeBx
  // 


  // ConditionName
  // 


  // CalorimeterConditionType
  // 

  CalorimeterConditionType::
  CalorimeterConditionType (value v)
  : ::xml_schema::string (_xsd_CalorimeterConditionType_literals_[v])
  {
  }

  CalorimeterConditionType::
  CalorimeterConditionType (const char* v)
  : ::xml_schema::string (v)
  {
  }

  CalorimeterConditionType::
  CalorimeterConditionType (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  CalorimeterConditionType::
  CalorimeterConditionType (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  CalorimeterConditionType::
  CalorimeterConditionType (const CalorimeterConditionType& v,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  CalorimeterConditionType& CalorimeterConditionType::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_CalorimeterConditionType_literals_[v]);

    return *this;
  }


  // CalorimeterObjectType
  // 

  CalorimeterObjectType::
  CalorimeterObjectType (value v)
  : ::xml_schema::string (_xsd_CalorimeterObjectType_literals_[v])
  {
  }

  CalorimeterObjectType::
  CalorimeterObjectType (const char* v)
  : ::xml_schema::string (v)
  {
  }

  CalorimeterObjectType::
  CalorimeterObjectType (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  CalorimeterObjectType::
  CalorimeterObjectType (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  CalorimeterObjectType::
  CalorimeterObjectType (const CalorimeterObjectType& v,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  CalorimeterObjectType& CalorimeterObjectType::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_CalorimeterObjectType_literals_[v]);

    return *this;
  }


  // Threshold
  // 


  // AlgorithmName
  // 


  // AlgorithmIndex
  // 


  // AlgorithmEquation
  // 


  // Meta
  // 

  const Meta::name_type& Meta::
  name () const
  {
    return this->name_.get ();
  }

  Meta::name_type& Meta::
  name ()
  {
    return this->name_.get ();
  }

  void Meta::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void Meta::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const Meta::scalesKey_type& Meta::
  scalesKey () const
  {
    return this->scalesKey_.get ();
  }

  Meta::scalesKey_type& Meta::
  scalesKey ()
  {
    return this->scalesKey_.get ();
  }

  void Meta::
  scalesKey (const scalesKey_type& x)
  {
    this->scalesKey_.set (x);
  }

  void Meta::
  scalesKey (::std::auto_ptr< scalesKey_type > x)
  {
    this->scalesKey_.set (x);
  }

  const Meta::firmwareVersion_type& Meta::
  firmwareVersion () const
  {
    return this->firmwareVersion_.get ();
  }

  Meta::firmwareVersion_type& Meta::
  firmwareVersion ()
  {
    return this->firmwareVersion_.get ();
  }

  void Meta::
  firmwareVersion (const firmwareVersion_type& x)
  {
    this->firmwareVersion_.set (x);
  }

  void Meta::
  firmwareVersion (::std::auto_ptr< firmwareVersion_type > x)
  {
    this->firmwareVersion_.set (x);
  }

  const Meta::description_type& Meta::
  description () const
  {
    return this->description_.get ();
  }

  Meta::description_type& Meta::
  description ()
  {
    return this->description_.get ();
  }

  void Meta::
  description (const description_type& x)
  {
    this->description_.set (x);
  }

  void Meta::
  description (::std::auto_ptr< description_type > x)
  {
    this->description_.set (x);
  }

  const Meta::history_type& Meta::
  history () const
  {
    return this->history_.get ();
  }

  Meta::history_type& Meta::
  history ()
  {
    return this->history_.get ();
  }

  void Meta::
  history (const history_type& x)
  {
    this->history_.set (x);
  }

  void Meta::
  history (::std::auto_ptr< history_type > x)
  {
    this->history_.set (x);
  }


  // ConditionList
  // 

  const ConditionList::condCalorimeter_sequence& ConditionList::
  condCalorimeter () const
  {
    return this->condCalorimeter_;
  }

  ConditionList::condCalorimeter_sequence& ConditionList::
  condCalorimeter ()
  {
    return this->condCalorimeter_;
  }

  void ConditionList::
  condCalorimeter (const condCalorimeter_sequence& s)
  {
    this->condCalorimeter_ = s;
  }

  const ConditionList::condMuon_sequence& ConditionList::
  condMuon () const
  {
    return this->condMuon_;
  }

  ConditionList::condMuon_sequence& ConditionList::
  condMuon ()
  {
    return this->condMuon_;
  }

  void ConditionList::
  condMuon (const condMuon_sequence& s)
  {
    this->condMuon_ = s;
  }

  const ConditionList::condEnergySum_sequence& ConditionList::
  condEnergySum () const
  {
    return this->condEnergySum_;
  }

  ConditionList::condEnergySum_sequence& ConditionList::
  condEnergySum ()
  {
    return this->condEnergySum_;
  }

  void ConditionList::
  condEnergySum (const condEnergySum_sequence& s)
  {
    this->condEnergySum_ = s;
  }

  const ConditionList::condCorrelation_sequence& ConditionList::
  condCorrelation () const
  {
    return this->condCorrelation_;
  }

  ConditionList::condCorrelation_sequence& ConditionList::
  condCorrelation ()
  {
    return this->condCorrelation_;
  }

  void ConditionList::
  condCorrelation (const condCorrelation_sequence& s)
  {
    this->condCorrelation_ = s;
  }

  const ConditionList::condInvariantMass_sequence& ConditionList::
  condInvariantMass () const
  {
    return this->condInvariantMass_;
  }

  ConditionList::condInvariantMass_sequence& ConditionList::
  condInvariantMass ()
  {
    return this->condInvariantMass_;
  }

  void ConditionList::
  condInvariantMass (const condInvariantMass_sequence& s)
  {
    this->condInvariantMass_ = s;
  }

  const ConditionList::condDeltaR_sequence& ConditionList::
  condDeltaR () const
  {
    return this->condDeltaR_;
  }

  ConditionList::condDeltaR_sequence& ConditionList::
  condDeltaR ()
  {
    return this->condDeltaR_;
  }

  void ConditionList::
  condDeltaR (const condDeltaR_sequence& s)
  {
    this->condDeltaR_ = s;
  }


  // Condition
  // 

  const Condition::name_type& Condition::
  name () const
  {
    return this->name_.get ();
  }

  Condition::name_type& Condition::
  name ()
  {
    return this->name_.get ();
  }

  void Condition::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void Condition::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const Condition::description_type& Condition::
  description () const
  {
    return this->description_.get ();
  }

  Condition::description_type& Condition::
  description ()
  {
    return this->description_.get ();
  }

  void Condition::
  description (const description_type& x)
  {
    this->description_.set (x);
  }

  void Condition::
  description (::std::auto_ptr< description_type > x)
  {
    this->description_.set (x);
  }

  const Condition::locked_type& Condition::
  locked () const
  {
    return this->locked_.get ();
  }

  Condition::locked_type& Condition::
  locked ()
  {
    return this->locked_.get ();
  }

  void Condition::
  locked (const locked_type& x)
  {
    this->locked_.set (x);
  }


  // Range
  // 

  const Range::begin_type& Range::
  begin () const
  {
    return this->begin_.get ();
  }

  Range::begin_type& Range::
  begin ()
  {
    return this->begin_.get ();
  }

  void Range::
  begin (const begin_type& x)
  {
    this->begin_.set (x);
  }

  const Range::end_type& Range::
  end () const
  {
    return this->end_.get ();
  }

  Range::end_type& Range::
  end ()
  {
    return this->end_.get ();
  }

  void Range::
  end (const end_type& x)
  {
    this->end_.set (x);
  }


  // DeltaRanges
  // 

  const DeltaRanges::deltaEtaRange_type& DeltaRanges::
  deltaEtaRange () const
  {
    return this->deltaEtaRange_.get ();
  }

  DeltaRanges::deltaEtaRange_type& DeltaRanges::
  deltaEtaRange ()
  {
    return this->deltaEtaRange_.get ();
  }

  void DeltaRanges::
  deltaEtaRange (const deltaEtaRange_type& x)
  {
    this->deltaEtaRange_.set (x);
  }

  void DeltaRanges::
  deltaEtaRange (::std::auto_ptr< deltaEtaRange_type > x)
  {
    this->deltaEtaRange_.set (x);
  }

  const DeltaRanges::deltaPhiRange_type& DeltaRanges::
  deltaPhiRange () const
  {
    return this->deltaPhiRange_.get ();
  }

  DeltaRanges::deltaPhiRange_type& DeltaRanges::
  deltaPhiRange ()
  {
    return this->deltaPhiRange_.get ();
  }

  void DeltaRanges::
  deltaPhiRange (const deltaPhiRange_type& x)
  {
    this->deltaPhiRange_.set (x);
  }

  void DeltaRanges::
  deltaPhiRange (::std::auto_ptr< deltaPhiRange_type > x)
  {
    this->deltaPhiRange_.set (x);
  }


  // CalorimeterObjectParameter
  // 

  const CalorimeterObjectParameter::etThreshold_type& CalorimeterObjectParameter::
  etThreshold () const
  {
    return this->etThreshold_.get ();
  }

  CalorimeterObjectParameter::etThreshold_type& CalorimeterObjectParameter::
  etThreshold ()
  {
    return this->etThreshold_.get ();
  }

  void CalorimeterObjectParameter::
  etThreshold (const etThreshold_type& x)
  {
    this->etThreshold_.set (x);
  }

  void CalorimeterObjectParameter::
  etThreshold (::std::auto_ptr< etThreshold_type > x)
  {
    this->etThreshold_.set (x);
  }

  const CalorimeterObjectParameter::phiRange_sequence& CalorimeterObjectParameter::
  phiRange () const
  {
    return this->phiRange_;
  }

  CalorimeterObjectParameter::phiRange_sequence& CalorimeterObjectParameter::
  phiRange ()
  {
    return this->phiRange_;
  }

  void CalorimeterObjectParameter::
  phiRange (const phiRange_sequence& s)
  {
    this->phiRange_ = s;
  }

  const CalorimeterObjectParameter::etaRange_sequence& CalorimeterObjectParameter::
  etaRange () const
  {
    return this->etaRange_;
  }

  CalorimeterObjectParameter::etaRange_sequence& CalorimeterObjectParameter::
  etaRange ()
  {
    return this->etaRange_;
  }

  void CalorimeterObjectParameter::
  etaRange (const etaRange_sequence& s)
  {
    this->etaRange_ = s;
  }


  // CalorimeterObjectParameters
  // 

  const CalorimeterObjectParameters::objectParameter_sequence& CalorimeterObjectParameters::
  objectParameter () const
  {
    return this->objectParameter_;
  }

  CalorimeterObjectParameters::objectParameter_sequence& CalorimeterObjectParameters::
  objectParameter ()
  {
    return this->objectParameter_;
  }

  void CalorimeterObjectParameters::
  objectParameter (const objectParameter_sequence& s)
  {
    this->objectParameter_ = s;
  }


  // CalorimeterCondition
  // 

  const CalorimeterCondition::type_type& CalorimeterCondition::
  type () const
  {
    return this->type_.get ();
  }

  CalorimeterCondition::type_type& CalorimeterCondition::
  type ()
  {
    return this->type_.get ();
  }

  void CalorimeterCondition::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void CalorimeterCondition::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const CalorimeterCondition::etComparison_type& CalorimeterCondition::
  etComparison () const
  {
    return this->etComparison_.get ();
  }

  CalorimeterCondition::etComparison_type& CalorimeterCondition::
  etComparison ()
  {
    return this->etComparison_.get ();
  }

  void CalorimeterCondition::
  etComparison (const etComparison_type& x)
  {
    this->etComparison_.set (x);
  }

  void CalorimeterCondition::
  etComparison (::std::auto_ptr< etComparison_type > x)
  {
    this->etComparison_.set (x);
  }

  const CalorimeterCondition::objectType_type& CalorimeterCondition::
  objectType () const
  {
    return this->objectType_.get ();
  }

  CalorimeterCondition::objectType_type& CalorimeterCondition::
  objectType ()
  {
    return this->objectType_.get ();
  }

  void CalorimeterCondition::
  objectType (const objectType_type& x)
  {
    this->objectType_.set (x);
  }

  void CalorimeterCondition::
  objectType (::std::auto_ptr< objectType_type > x)
  {
    this->objectType_.set (x);
  }

  const CalorimeterCondition::objectParameters_type& CalorimeterCondition::
  objectParameters () const
  {
    return this->objectParameters_.get ();
  }

  CalorimeterCondition::objectParameters_type& CalorimeterCondition::
  objectParameters ()
  {
    return this->objectParameters_.get ();
  }

  void CalorimeterCondition::
  objectParameters (const objectParameters_type& x)
  {
    this->objectParameters_.set (x);
  }

  void CalorimeterCondition::
  objectParameters (::std::auto_ptr< objectParameters_type > x)
  {
    this->objectParameters_.set (x);
  }

  const CalorimeterCondition::deltaRanges_optional& CalorimeterCondition::
  deltaRanges () const
  {
    return this->deltaRanges_;
  }

  CalorimeterCondition::deltaRanges_optional& CalorimeterCondition::
  deltaRanges ()
  {
    return this->deltaRanges_;
  }

  void CalorimeterCondition::
  deltaRanges (const deltaRanges_type& x)
  {
    this->deltaRanges_.set (x);
  }

  void CalorimeterCondition::
  deltaRanges (const deltaRanges_optional& x)
  {
    this->deltaRanges_ = x;
  }

  void CalorimeterCondition::
  deltaRanges (::std::auto_ptr< deltaRanges_type > x)
  {
    this->deltaRanges_.set (x);
  }

  const CalorimeterCondition::relativeBx_type& CalorimeterCondition::
  relativeBx () const
  {
    return this->relativeBx_.get ();
  }

  CalorimeterCondition::relativeBx_type& CalorimeterCondition::
  relativeBx ()
  {
    return this->relativeBx_.get ();
  }

  void CalorimeterCondition::
  relativeBx (const relativeBx_type& x)
  {
    this->relativeBx_.set (x);
  }

  void CalorimeterCondition::
  relativeBx (::std::auto_ptr< relativeBx_type > x)
  {
    this->relativeBx_.set (x);
  }


  // MuonCondition
  // 


  // EnergySumCondition
  // 


  // CorrelationCondition
  // 


  // InvariantMassCondition
  // 


  // DeltaRCondition
  // 


  // Algorithm
  // 

  const Algorithm::name_type& Algorithm::
  name () const
  {
    return this->name_.get ();
  }

  Algorithm::name_type& Algorithm::
  name ()
  {
    return this->name_.get ();
  }

  void Algorithm::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void Algorithm::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const Algorithm::index_type& Algorithm::
  index () const
  {
    return this->index_.get ();
  }

  Algorithm::index_type& Algorithm::
  index ()
  {
    return this->index_.get ();
  }

  void Algorithm::
  index (const index_type& x)
  {
    this->index_.set (x);
  }

  void Algorithm::
  index (::std::auto_ptr< index_type > x)
  {
    this->index_.set (x);
  }

  const Algorithm::equation_type& Algorithm::
  equation () const
  {
    return this->equation_.get ();
  }

  Algorithm::equation_type& Algorithm::
  equation ()
  {
    return this->equation_.get ();
  }

  void Algorithm::
  equation (const equation_type& x)
  {
    this->equation_.set (x);
  }

  void Algorithm::
  equation (::std::auto_ptr< equation_type > x)
  {
    this->equation_.set (x);
  }

  const Algorithm::description_type& Algorithm::
  description () const
  {
    return this->description_.get ();
  }

  Algorithm::description_type& Algorithm::
  description ()
  {
    return this->description_.get ();
  }

  void Algorithm::
  description (const description_type& x)
  {
    this->description_.set (x);
  }

  void Algorithm::
  description (::std::auto_ptr< description_type > x)
  {
    this->description_.set (x);
  }

  const Algorithm::locked_type& Algorithm::
  locked () const
  {
    return this->locked_.get ();
  }

  Algorithm::locked_type& Algorithm::
  locked ()
  {
    return this->locked_.get ();
  }

  void Algorithm::
  locked (const locked_type& x)
  {
    this->locked_.set (x);
  }


  // AlgorithmList
  // 

  const AlgorithmList::algorithm_sequence& AlgorithmList::
  algorithm () const
  {
    return this->algorithm_;
  }

  AlgorithmList::algorithm_sequence& AlgorithmList::
  algorithm ()
  {
    return this->algorithm_;
  }

  void AlgorithmList::
  algorithm (const algorithm_sequence& s)
  {
    this->algorithm_ = s;
  }


  // L1TriggerMenu
  // 

  const L1TriggerMenu::meta_type& L1TriggerMenu::
  meta () const
  {
    return this->meta_.get ();
  }

  L1TriggerMenu::meta_type& L1TriggerMenu::
  meta ()
  {
    return this->meta_.get ();
  }

  void L1TriggerMenu::
  meta (const meta_type& x)
  {
    this->meta_.set (x);
  }

  void L1TriggerMenu::
  meta (::std::auto_ptr< meta_type > x)
  {
    this->meta_.set (x);
  }

  const L1TriggerMenu::conditions_type& L1TriggerMenu::
  conditions () const
  {
    return this->conditions_.get ();
  }

  L1TriggerMenu::conditions_type& L1TriggerMenu::
  conditions ()
  {
    return this->conditions_.get ();
  }

  void L1TriggerMenu::
  conditions (const conditions_type& x)
  {
    this->conditions_.set (x);
  }

  void L1TriggerMenu::
  conditions (::std::auto_ptr< conditions_type > x)
  {
    this->conditions_.set (x);
  }

  const L1TriggerMenu::algorithms_type& L1TriggerMenu::
  algorithms () const
  {
    return this->algorithms_.get ();
  }

  L1TriggerMenu::algorithms_type& L1TriggerMenu::
  algorithms ()
  {
    return this->algorithms_.get ();
  }

  void L1TriggerMenu::
  algorithms (const algorithms_type& x)
  {
    this->algorithms_.set (x);
  }

  void L1TriggerMenu::
  algorithms (::std::auto_ptr< algorithms_type > x)
  {
    this->algorithms_.set (x);
  }

  const L1TriggerMenu::version_type& L1TriggerMenu::
  version () const
  {
    return this->version_.get ();
  }

  const L1TriggerMenu::version_type& L1TriggerMenu::
  version_default_value ()
  {
    return version_default_value_;
  }
}

#include <L1Trigger/L1TGlobal/src/L1TMenuEditor/xsd/cxx/xml/dom/parsing-source.hxx>

namespace l1t
{
  // DateTime
  //

  DateTime::
  DateTime (const ::xml_schema::date_time& _xsd_date_time_base)
  : ::xml_schema::date_time (_xsd_date_time_base)
  {
  }

  DateTime::
  DateTime (const DateTime& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::date_time (x, f, c)
  {
  }

  DateTime::
  DateTime (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::date_time (e, f, c)
  {
  }

  DateTime::
  DateTime (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::date_time (a, f, c)
  {
  }

  DateTime::
  DateTime (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::date_time (s, e, f, c)
  {
  }

  DateTime* DateTime::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DateTime (*this, f, c);
  }

  DateTime::
  ~DateTime ()
  {
  }

  // Label
  //

  Label::
  Label ()
  : ::xml_schema::string ()
  {
  }

  Label::
  Label (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Label::
  Label (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Label::
  Label (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Label::
  Label (const Label& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  Label::
  Label (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  Label::
  Label (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  Label::
  Label (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  Label* Label::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Label (*this, f, c);
  }

  Label::
  ~Label ()
  {
  }

  // Description
  //

  Description::
  Description ()
  : ::xml_schema::string ()
  {
  }

  Description::
  Description (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Description::
  Description (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Description::
  Description (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Description::
  Description (const Description& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  Description::
  Description (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  Description::
  Description (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  Description::
  Description (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  Description* Description::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Description (*this, f, c);
  }

  Description::
  ~Description ()
  {
  }

  // MenuName
  //

  MenuName::
  MenuName ()
  : ::xml_schema::string ()
  {
  }

  MenuName::
  MenuName (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  MenuName::
  MenuName (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  MenuName::
  MenuName (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  MenuName::
  MenuName (const MenuName& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  MenuName::
  MenuName (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  MenuName::
  MenuName (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  MenuName::
  MenuName (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  MenuName* MenuName::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MenuName (*this, f, c);
  }

  MenuName::
  ~MenuName ()
  {
  }

  // ScalesKey
  //

  ScalesKey::
  ScalesKey ()
  : ::xml_schema::string ()
  {
  }

  ScalesKey::
  ScalesKey (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  ScalesKey::
  ScalesKey (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  ScalesKey::
  ScalesKey (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  ScalesKey::
  ScalesKey (const ScalesKey& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  ScalesKey::
  ScalesKey (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  ScalesKey::
  ScalesKey (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  ScalesKey::
  ScalesKey (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  ScalesKey* ScalesKey::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ScalesKey (*this, f, c);
  }

  ScalesKey::
  ~ScalesKey ()
  {
  }

  // FirmwareVersion
  //

  FirmwareVersion::
  FirmwareVersion (const ::xml_schema::unsigned_int& _xsd_unsigned_int_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (_xsd_unsigned_int_base)
  {
  }

  FirmwareVersion::
  FirmwareVersion (const FirmwareVersion& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  FirmwareVersion::
  FirmwareVersion (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  FirmwareVersion::
  FirmwareVersion (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  FirmwareVersion::
  FirmwareVersion (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  FirmwareVersion* FirmwareVersion::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FirmwareVersion (*this, f, c);
  }

  FirmwareVersion::
  ~FirmwareVersion ()
  {
  }

  // History
  //

  History::
  History ()
  : ::xml_schema::type (),
    revision_ (::xml_schema::flags (), this)
  {
  }

  History::
  History (const History& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    revision_ (x.revision_, f, this)
  {
  }

  History::
  History (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    revision_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void History::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // revision
      //
      if (n.name () == "revision" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< revision_type > r (
          revision_traits::create (i, f, this));

        this->revision_.push_back (r);
        continue;
      }

      break;
    }
  }

  History* History::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class History (*this, f, c);
  }

  History::
  ~History ()
  {
  }

  // Revision
  //

  Revision::
  Revision (const author_type& author,
            const datetime_type& datetime)
  : ::xml_schema::type (),
    author_ (author, ::xml_schema::flags (), this),
    datetime_ (datetime, ::xml_schema::flags (), this),
    username_ (::xml_schema::flags (), this),
    hostname_ (::xml_schema::flags (), this)
  {
  }

  Revision::
  Revision (const Revision& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    author_ (x.author_, f, this),
    datetime_ (x.datetime_, f, this),
    username_ (x.username_, f, this),
    hostname_ (x.hostname_, f, this)
  {
  }

  Revision::
  Revision (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    author_ (f, this),
    datetime_ (f, this),
    username_ (f, this),
    hostname_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void Revision::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // author
      //
      if (n.name () == "author" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< author_type > r (
          author_traits::create (i, f, this));

        if (!author_.present ())
        {
          this->author_.set (r);
          continue;
        }
      }

      // datetime
      //
      if (n.name () == "datetime" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< datetime_type > r (
          datetime_traits::create (i, f, this));

        if (!datetime_.present ())
        {
          this->datetime_.set (r);
          continue;
        }
      }

      break;
    }

    if (!author_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "author",
        "http://www.cern.ch/l1t");
    }

    if (!datetime_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "datetime",
        "http://www.cern.ch/l1t");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "username" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< username_type > r (
          username_traits::create (i, f, this));

        this->username_.set (r);
        continue;
      }

      if (n.name () == "hostname" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< hostname_type > r (
          hostname_traits::create (i, f, this));

        this->hostname_.set (r);
        continue;
      }
    }
  }

  Revision* Revision::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Revision (*this, f, c);
  }

  Revision::
  ~Revision ()
  {
  }

  // ConditionEtComparison
  //

  ConditionEtComparison::
  ConditionEtComparison (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_ConditionEtComparison_convert ();
  }

  ConditionEtComparison::
  ConditionEtComparison (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_ConditionEtComparison_convert ();
  }

  ConditionEtComparison::
  ConditionEtComparison (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_ConditionEtComparison_convert ();
  }

  ConditionEtComparison* ConditionEtComparison::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ConditionEtComparison (*this, f, c);
  }

  ConditionEtComparison::value ConditionEtComparison::
  _xsd_ConditionEtComparison_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ConditionEtComparison_literals_);
    const value* i (::std::lower_bound (
                      _xsd_ConditionEtComparison_indexes_,
                      _xsd_ConditionEtComparison_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_ConditionEtComparison_indexes_ + 2 || _xsd_ConditionEtComparison_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const ConditionEtComparison::
  _xsd_ConditionEtComparison_literals_[2] =
  {
    "eq",
    "ge"
  };

  const ConditionEtComparison::value ConditionEtComparison::
  _xsd_ConditionEtComparison_indexes_[2] =
  {
    ::l1t::ConditionEtComparison::eq,
    ::l1t::ConditionEtComparison::ge
  };

  // RelativeBx
  //

  RelativeBx::
  RelativeBx (const ::xml_schema::integer& _xsd_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (_xsd_integer_base)
  {
  }

  RelativeBx::
  RelativeBx (const RelativeBx& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  RelativeBx::
  RelativeBx (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  RelativeBx::
  RelativeBx (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  RelativeBx::
  RelativeBx (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  RelativeBx* RelativeBx::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RelativeBx (*this, f, c);
  }

  RelativeBx::
  ~RelativeBx ()
  {
  }

  // ConditionName
  //

  ConditionName::
  ConditionName ()
  : ::xml_schema::string ()
  {
  }

  ConditionName::
  ConditionName (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  ConditionName::
  ConditionName (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  ConditionName::
  ConditionName (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  ConditionName::
  ConditionName (const ConditionName& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  ConditionName::
  ConditionName (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  ConditionName::
  ConditionName (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  ConditionName::
  ConditionName (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  ConditionName* ConditionName::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ConditionName (*this, f, c);
  }

  ConditionName::
  ~ConditionName ()
  {
  }

  // CalorimeterConditionType
  //

  CalorimeterConditionType::
  CalorimeterConditionType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_CalorimeterConditionType_convert ();
  }

  CalorimeterConditionType::
  CalorimeterConditionType (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_CalorimeterConditionType_convert ();
  }

  CalorimeterConditionType::
  CalorimeterConditionType (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_CalorimeterConditionType_convert ();
  }

  CalorimeterConditionType* CalorimeterConditionType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CalorimeterConditionType (*this, f, c);
  }

  CalorimeterConditionType::value CalorimeterConditionType::
  _xsd_CalorimeterConditionType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_CalorimeterConditionType_literals_);
    const value* i (::std::lower_bound (
                      _xsd_CalorimeterConditionType_indexes_,
                      _xsd_CalorimeterConditionType_indexes_ + 5,
                      *this,
                      c));

    if (i == _xsd_CalorimeterConditionType_indexes_ + 5 || _xsd_CalorimeterConditionType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const CalorimeterConditionType::
  _xsd_CalorimeterConditionType_literals_[5] =
  {
    "single",
    "double",
    "triple",
    "quad",
    "double_wsc"
  };

  const CalorimeterConditionType::value CalorimeterConditionType::
  _xsd_CalorimeterConditionType_indexes_[5] =
  {
    ::l1t::CalorimeterConditionType::double_,
    ::l1t::CalorimeterConditionType::double_wsc,
    ::l1t::CalorimeterConditionType::quad,
    ::l1t::CalorimeterConditionType::single,
    ::l1t::CalorimeterConditionType::triple
  };

  // CalorimeterObjectType
  //

  CalorimeterObjectType::
  CalorimeterObjectType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_CalorimeterObjectType_convert ();
  }

  CalorimeterObjectType::
  CalorimeterObjectType (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_CalorimeterObjectType_convert ();
  }

  CalorimeterObjectType::
  CalorimeterObjectType (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_CalorimeterObjectType_convert ();
  }

  CalorimeterObjectType* CalorimeterObjectType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CalorimeterObjectType (*this, f, c);
  }

  CalorimeterObjectType::value CalorimeterObjectType::
  _xsd_CalorimeterObjectType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_CalorimeterObjectType_literals_);
    const value* i (::std::lower_bound (
                      _xsd_CalorimeterObjectType_indexes_,
                      _xsd_CalorimeterObjectType_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_CalorimeterObjectType_indexes_ + 3 || _xsd_CalorimeterObjectType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const CalorimeterObjectType::
  _xsd_CalorimeterObjectType_literals_[3] =
  {
    "eg",
    "jet",
    "tau"
  };

  const CalorimeterObjectType::value CalorimeterObjectType::
  _xsd_CalorimeterObjectType_indexes_[3] =
  {
    ::l1t::CalorimeterObjectType::eg,
    ::l1t::CalorimeterObjectType::jet,
    ::l1t::CalorimeterObjectType::tau
  };

  // Threshold
  //

  Threshold::
  Threshold (const ::xml_schema::unsigned_int& _xsd_unsigned_int_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (_xsd_unsigned_int_base)
  {
  }

  Threshold::
  Threshold (const Threshold& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  Threshold::
  Threshold (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  Threshold::
  Threshold (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  Threshold::
  Threshold (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  Threshold* Threshold::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Threshold (*this, f, c);
  }

  Threshold::
  ~Threshold ()
  {
  }

  // AlgorithmName
  //

  AlgorithmName::
  AlgorithmName ()
  : ::xml_schema::string ()
  {
  }

  AlgorithmName::
  AlgorithmName (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  AlgorithmName::
  AlgorithmName (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  AlgorithmName::
  AlgorithmName (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  AlgorithmName::
  AlgorithmName (const AlgorithmName& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  AlgorithmName::
  AlgorithmName (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  AlgorithmName::
  AlgorithmName (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  AlgorithmName::
  AlgorithmName (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  AlgorithmName* AlgorithmName::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AlgorithmName (*this, f, c);
  }

  AlgorithmName::
  ~AlgorithmName ()
  {
  }

  // AlgorithmIndex
  //

  AlgorithmIndex::
  AlgorithmIndex (const ::xml_schema::unsigned_int& _xsd_unsigned_int_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (_xsd_unsigned_int_base)
  {
  }

  AlgorithmIndex::
  AlgorithmIndex (const AlgorithmIndex& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  AlgorithmIndex::
  AlgorithmIndex (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  AlgorithmIndex::
  AlgorithmIndex (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  AlgorithmIndex::
  AlgorithmIndex (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  AlgorithmIndex* AlgorithmIndex::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AlgorithmIndex (*this, f, c);
  }

  AlgorithmIndex::
  ~AlgorithmIndex ()
  {
  }

  // AlgorithmEquation
  //

  AlgorithmEquation::
  AlgorithmEquation ()
  : ::xml_schema::string ()
  {
  }

  AlgorithmEquation::
  AlgorithmEquation (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  AlgorithmEquation::
  AlgorithmEquation (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  AlgorithmEquation::
  AlgorithmEquation (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  AlgorithmEquation::
  AlgorithmEquation (const AlgorithmEquation& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  AlgorithmEquation::
  AlgorithmEquation (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  AlgorithmEquation::
  AlgorithmEquation (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  AlgorithmEquation::
  AlgorithmEquation (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  AlgorithmEquation* AlgorithmEquation::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AlgorithmEquation (*this, f, c);
  }

  AlgorithmEquation::
  ~AlgorithmEquation ()
  {
  }

  // Meta
  //

  Meta::
  Meta (const name_type& name,
        const scalesKey_type& scalesKey,
        const firmwareVersion_type& firmwareVersion,
        const description_type& description,
        const history_type& history)
  : ::xml_schema::type (),
    name_ (name, ::xml_schema::flags (), this),
    scalesKey_ (scalesKey, ::xml_schema::flags (), this),
    firmwareVersion_ (firmwareVersion, ::xml_schema::flags (), this),
    description_ (description, ::xml_schema::flags (), this),
    history_ (history, ::xml_schema::flags (), this)
  {
  }

  Meta::
  Meta (const name_type& name,
        const scalesKey_type& scalesKey,
        const firmwareVersion_type& firmwareVersion,
        const description_type& description,
        ::std::auto_ptr< history_type >& history)
  : ::xml_schema::type (),
    name_ (name, ::xml_schema::flags (), this),
    scalesKey_ (scalesKey, ::xml_schema::flags (), this),
    firmwareVersion_ (firmwareVersion, ::xml_schema::flags (), this),
    description_ (description, ::xml_schema::flags (), this),
    history_ (history, ::xml_schema::flags (), this)
  {
  }

  Meta::
  Meta (const Meta& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    name_ (x.name_, f, this),
    scalesKey_ (x.scalesKey_, f, this),
    firmwareVersion_ (x.firmwareVersion_, f, this),
    description_ (x.description_, f, this),
    history_ (x.history_, f, this)
  {
  }

  Meta::
  Meta (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    name_ (f, this),
    scalesKey_ (f, this),
    firmwareVersion_ (f, this),
    description_ (f, this),
    history_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void Meta::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        if (!name_.present ())
        {
          this->name_.set (r);
          continue;
        }
      }

      // scalesKey
      //
      if (n.name () == "scalesKey" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< scalesKey_type > r (
          scalesKey_traits::create (i, f, this));

        if (!scalesKey_.present ())
        {
          this->scalesKey_.set (r);
          continue;
        }
      }

      // firmwareVersion
      //
      if (n.name () == "firmwareVersion" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< firmwareVersion_type > r (
          firmwareVersion_traits::create (i, f, this));

        if (!firmwareVersion_.present ())
        {
          this->firmwareVersion_.set (r);
          continue;
        }
      }

      // description
      //
      if (n.name () == "description" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< description_type > r (
          description_traits::create (i, f, this));

        if (!description_.present ())
        {
          this->description_.set (r);
          continue;
        }
      }

      // history
      //
      if (n.name () == "history" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< history_type > r (
          history_traits::create (i, f, this));

        if (!history_.present ())
        {
          this->history_.set (r);
          continue;
        }
      }

      break;
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "name",
        "http://www.cern.ch/l1t");
    }

    if (!scalesKey_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "scalesKey",
        "http://www.cern.ch/l1t");
    }

    if (!firmwareVersion_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "firmwareVersion",
        "http://www.cern.ch/l1t");
    }

    if (!description_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "description",
        "http://www.cern.ch/l1t");
    }

    if (!history_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "history",
        "http://www.cern.ch/l1t");
    }
  }

  Meta* Meta::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Meta (*this, f, c);
  }

  Meta::
  ~Meta ()
  {
  }

  // ConditionList
  //

  ConditionList::
  ConditionList ()
  : ::xml_schema::type (),
    condCalorimeter_ (::xml_schema::flags (), this),
    condMuon_ (::xml_schema::flags (), this),
    condEnergySum_ (::xml_schema::flags (), this),
    condCorrelation_ (::xml_schema::flags (), this),
    condInvariantMass_ (::xml_schema::flags (), this),
    condDeltaR_ (::xml_schema::flags (), this)
  {
  }

  ConditionList::
  ConditionList (const ConditionList& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    condCalorimeter_ (x.condCalorimeter_, f, this),
    condMuon_ (x.condMuon_, f, this),
    condEnergySum_ (x.condEnergySum_, f, this),
    condCorrelation_ (x.condCorrelation_, f, this),
    condInvariantMass_ (x.condInvariantMass_, f, this),
    condDeltaR_ (x.condDeltaR_, f, this)
  {
  }

  ConditionList::
  ConditionList (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    condCalorimeter_ (f, this),
    condMuon_ (f, this),
    condEnergySum_ (f, this),
    condCorrelation_ (f, this),
    condInvariantMass_ (f, this),
    condDeltaR_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ConditionList::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // condCalorimeter
      //
      if (n.name () == "condCalorimeter" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< condCalorimeter_type > r (
          condCalorimeter_traits::create (i, f, this));

        this->condCalorimeter_.push_back (r);
        continue;
      }

      // condMuon
      //
      if (n.name () == "condMuon" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< condMuon_type > r (
          condMuon_traits::create (i, f, this));

        this->condMuon_.push_back (r);
        continue;
      }

      // condEnergySum
      //
      if (n.name () == "condEnergySum" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< condEnergySum_type > r (
          condEnergySum_traits::create (i, f, this));

        this->condEnergySum_.push_back (r);
        continue;
      }

      // condCorrelation
      //
      if (n.name () == "condCorrelation" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< condCorrelation_type > r (
          condCorrelation_traits::create (i, f, this));

        this->condCorrelation_.push_back (r);
        continue;
      }

      // condInvariantMass
      //
      if (n.name () == "condInvariantMass" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< condInvariantMass_type > r (
          condInvariantMass_traits::create (i, f, this));

        this->condInvariantMass_.push_back (r);
        continue;
      }

      // condDeltaR
      //
      if (n.name () == "condDeltaR" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< condDeltaR_type > r (
          condDeltaR_traits::create (i, f, this));

        this->condDeltaR_.push_back (r);
        continue;
      }

      break;
    }
  }

  ConditionList* ConditionList::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ConditionList (*this, f, c);
  }

  ConditionList::
  ~ConditionList ()
  {
  }

  // Condition
  //

  Condition::
  Condition (const name_type& name,
             const description_type& description,
             const locked_type& locked)
  : ::xml_schema::type (),
    name_ (name, ::xml_schema::flags (), this),
    description_ (description, ::xml_schema::flags (), this),
    locked_ (locked, ::xml_schema::flags (), this)
  {
  }

  Condition::
  Condition (const Condition& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    name_ (x.name_, f, this),
    description_ (x.description_, f, this),
    locked_ (x.locked_, f, this)
  {
  }

  Condition::
  Condition (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    name_ (f, this),
    description_ (f, this),
    locked_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void Condition::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        if (!name_.present ())
        {
          this->name_.set (r);
          continue;
        }
      }

      // description
      //
      if (n.name () == "description" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< description_type > r (
          description_traits::create (i, f, this));

        if (!description_.present ())
        {
          this->description_.set (r);
          continue;
        }
      }

      // locked
      //
      if (n.name () == "locked" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        if (!locked_.present ())
        {
          this->locked_.set (locked_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "name",
        "http://www.cern.ch/l1t");
    }

    if (!description_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "description",
        "http://www.cern.ch/l1t");
    }

    if (!locked_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "locked",
        "http://www.cern.ch/l1t");
    }
  }

  Condition* Condition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Condition (*this, f, c);
  }

  Condition::
  ~Condition ()
  {
  }

  // Range
  //

  Range::
  Range (const begin_type& begin,
         const end_type& end)
  : ::xml_schema::type (),
    begin_ (begin, ::xml_schema::flags (), this),
    end_ (end, ::xml_schema::flags (), this)
  {
  }

  Range::
  Range (const Range& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    begin_ (x.begin_, f, this),
    end_ (x.end_, f, this)
  {
  }

  Range::
  Range (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    begin_ (f, this),
    end_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void Range::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // begin
      //
      if (n.name () == "begin" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        if (!begin_.present ())
        {
          this->begin_.set (begin_traits::create (i, f, this));
          continue;
        }
      }

      // end
      //
      if (n.name () == "end" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        if (!end_.present ())
        {
          this->end_.set (end_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!begin_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "begin",
        "http://www.cern.ch/l1t");
    }

    if (!end_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "end",
        "http://www.cern.ch/l1t");
    }
  }

  Range* Range::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Range (*this, f, c);
  }

  Range::
  ~Range ()
  {
  }

  // DeltaRanges
  //

  DeltaRanges::
  DeltaRanges (const deltaEtaRange_type& deltaEtaRange,
               const deltaPhiRange_type& deltaPhiRange)
  : ::xml_schema::type (),
    deltaEtaRange_ (deltaEtaRange, ::xml_schema::flags (), this),
    deltaPhiRange_ (deltaPhiRange, ::xml_schema::flags (), this)
  {
  }

  DeltaRanges::
  DeltaRanges (::std::auto_ptr< deltaEtaRange_type >& deltaEtaRange,
               ::std::auto_ptr< deltaPhiRange_type >& deltaPhiRange)
  : ::xml_schema::type (),
    deltaEtaRange_ (deltaEtaRange, ::xml_schema::flags (), this),
    deltaPhiRange_ (deltaPhiRange, ::xml_schema::flags (), this)
  {
  }

  DeltaRanges::
  DeltaRanges (const DeltaRanges& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    deltaEtaRange_ (x.deltaEtaRange_, f, this),
    deltaPhiRange_ (x.deltaPhiRange_, f, this)
  {
  }

  DeltaRanges::
  DeltaRanges (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    deltaEtaRange_ (f, this),
    deltaPhiRange_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void DeltaRanges::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // deltaEtaRange
      //
      if (n.name () == "deltaEtaRange" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< deltaEtaRange_type > r (
          deltaEtaRange_traits::create (i, f, this));

        if (!deltaEtaRange_.present ())
        {
          this->deltaEtaRange_.set (r);
          continue;
        }
      }

      // deltaPhiRange
      //
      if (n.name () == "deltaPhiRange" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< deltaPhiRange_type > r (
          deltaPhiRange_traits::create (i, f, this));

        if (!deltaPhiRange_.present ())
        {
          this->deltaPhiRange_.set (r);
          continue;
        }
      }

      break;
    }

    if (!deltaEtaRange_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "deltaEtaRange",
        "http://www.cern.ch/l1t");
    }

    if (!deltaPhiRange_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "deltaPhiRange",
        "http://www.cern.ch/l1t");
    }
  }

  DeltaRanges* DeltaRanges::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DeltaRanges (*this, f, c);
  }

  DeltaRanges::
  ~DeltaRanges ()
  {
  }

  // CalorimeterObjectParameter
  //

  CalorimeterObjectParameter::
  CalorimeterObjectParameter (const etThreshold_type& etThreshold)
  : ::xml_schema::type (),
    etThreshold_ (etThreshold, ::xml_schema::flags (), this),
    phiRange_ (::xml_schema::flags (), this),
    etaRange_ (::xml_schema::flags (), this)
  {
  }

  CalorimeterObjectParameter::
  CalorimeterObjectParameter (const CalorimeterObjectParameter& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    etThreshold_ (x.etThreshold_, f, this),
    phiRange_ (x.phiRange_, f, this),
    etaRange_ (x.etaRange_, f, this)
  {
  }

  CalorimeterObjectParameter::
  CalorimeterObjectParameter (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    etThreshold_ (f, this),
    phiRange_ (f, this),
    etaRange_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void CalorimeterObjectParameter::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // etThreshold
      //
      if (n.name () == "etThreshold" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< etThreshold_type > r (
          etThreshold_traits::create (i, f, this));

        if (!etThreshold_.present ())
        {
          this->etThreshold_.set (r);
          continue;
        }
      }

      // phiRange
      //
      if (n.name () == "phiRange" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< phiRange_type > r (
          phiRange_traits::create (i, f, this));

        this->phiRange_.push_back (r);
        continue;
      }

      // etaRange
      //
      if (n.name () == "etaRange" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< etaRange_type > r (
          etaRange_traits::create (i, f, this));

        this->etaRange_.push_back (r);
        continue;
      }

      break;
    }

    if (!etThreshold_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "etThreshold",
        "http://www.cern.ch/l1t");
    }
  }

  CalorimeterObjectParameter* CalorimeterObjectParameter::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CalorimeterObjectParameter (*this, f, c);
  }

  CalorimeterObjectParameter::
  ~CalorimeterObjectParameter ()
  {
  }

  // CalorimeterObjectParameters
  //

  CalorimeterObjectParameters::
  CalorimeterObjectParameters ()
  : ::xml_schema::type (),
    objectParameter_ (::xml_schema::flags (), this)
  {
  }

  CalorimeterObjectParameters::
  CalorimeterObjectParameters (const CalorimeterObjectParameters& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    objectParameter_ (x.objectParameter_, f, this)
  {
  }

  CalorimeterObjectParameters::
  CalorimeterObjectParameters (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    objectParameter_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void CalorimeterObjectParameters::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // objectParameter
      //
      if (n.name () == "objectParameter" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< objectParameter_type > r (
          objectParameter_traits::create (i, f, this));

        this->objectParameter_.push_back (r);
        continue;
      }

      break;
    }
  }

  CalorimeterObjectParameters* CalorimeterObjectParameters::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CalorimeterObjectParameters (*this, f, c);
  }

  CalorimeterObjectParameters::
  ~CalorimeterObjectParameters ()
  {
  }

  // CalorimeterCondition
  //

  CalorimeterCondition::
  CalorimeterCondition (const name_type& name,
                        const description_type& description,
                        const locked_type& locked,
                        const type_type& type,
                        const etComparison_type& etComparison,
                        const objectType_type& objectType,
                        const objectParameters_type& objectParameters,
                        const relativeBx_type& relativeBx)
  : ::l1t::Condition (name,
                      description,
                      locked),
    type_ (type, ::xml_schema::flags (), this),
    etComparison_ (etComparison, ::xml_schema::flags (), this),
    objectType_ (objectType, ::xml_schema::flags (), this),
    objectParameters_ (objectParameters, ::xml_schema::flags (), this),
    deltaRanges_ (::xml_schema::flags (), this),
    relativeBx_ (relativeBx, ::xml_schema::flags (), this)
  {
  }

  CalorimeterCondition::
  CalorimeterCondition (const name_type& name,
                        const description_type& description,
                        const locked_type& locked,
                        const type_type& type,
                        const etComparison_type& etComparison,
                        const objectType_type& objectType,
                        ::std::auto_ptr< objectParameters_type >& objectParameters,
                        const relativeBx_type& relativeBx)
  : ::l1t::Condition (name,
                      description,
                      locked),
    type_ (type, ::xml_schema::flags (), this),
    etComparison_ (etComparison, ::xml_schema::flags (), this),
    objectType_ (objectType, ::xml_schema::flags (), this),
    objectParameters_ (objectParameters, ::xml_schema::flags (), this),
    deltaRanges_ (::xml_schema::flags (), this),
    relativeBx_ (relativeBx, ::xml_schema::flags (), this)
  {
  }

  CalorimeterCondition::
  CalorimeterCondition (const CalorimeterCondition& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::l1t::Condition (x, f, c),
    type_ (x.type_, f, this),
    etComparison_ (x.etComparison_, f, this),
    objectType_ (x.objectType_, f, this),
    objectParameters_ (x.objectParameters_, f, this),
    deltaRanges_ (x.deltaRanges_, f, this),
    relativeBx_ (x.relativeBx_, f, this)
  {
  }

  CalorimeterCondition::
  CalorimeterCondition (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::l1t::Condition (e, f | ::xml_schema::flags::base, c),
    type_ (f, this),
    etComparison_ (f, this),
    objectType_ (f, this),
    objectParameters_ (f, this),
    deltaRanges_ (f, this),
    relativeBx_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void CalorimeterCondition::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::l1t::Condition::parse (p, f);

    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // type
      //
      if (n.name () == "type" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        if (!type_.present ())
        {
          this->type_.set (r);
          continue;
        }
      }

      // etComparison
      //
      if (n.name () == "etComparison" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< etComparison_type > r (
          etComparison_traits::create (i, f, this));

        if (!etComparison_.present ())
        {
          this->etComparison_.set (r);
          continue;
        }
      }

      // objectType
      //
      if (n.name () == "objectType" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< objectType_type > r (
          objectType_traits::create (i, f, this));

        if (!objectType_.present ())
        {
          this->objectType_.set (r);
          continue;
        }
      }

      // objectParameters
      //
      if (n.name () == "objectParameters" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< objectParameters_type > r (
          objectParameters_traits::create (i, f, this));

        if (!objectParameters_.present ())
        {
          this->objectParameters_.set (r);
          continue;
        }
      }

      // deltaRanges
      //
      if (n.name () == "deltaRanges" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< deltaRanges_type > r (
          deltaRanges_traits::create (i, f, this));

        if (!this->deltaRanges_)
        {
          this->deltaRanges_.set (r);
          continue;
        }
      }

      // relativeBx
      //
      if (n.name () == "relativeBx" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< relativeBx_type > r (
          relativeBx_traits::create (i, f, this));

        if (!relativeBx_.present ())
        {
          this->relativeBx_.set (r);
          continue;
        }
      }

      break;
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "type",
        "http://www.cern.ch/l1t");
    }

    if (!etComparison_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "etComparison",
        "http://www.cern.ch/l1t");
    }

    if (!objectType_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "objectType",
        "http://www.cern.ch/l1t");
    }

    if (!objectParameters_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "objectParameters",
        "http://www.cern.ch/l1t");
    }

    if (!relativeBx_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "relativeBx",
        "http://www.cern.ch/l1t");
    }
  }

  CalorimeterCondition* CalorimeterCondition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CalorimeterCondition (*this, f, c);
  }

  CalorimeterCondition::
  ~CalorimeterCondition ()
  {
  }

  // MuonCondition
  //

  MuonCondition::
  MuonCondition (const name_type& name,
                 const description_type& description,
                 const locked_type& locked)
  : ::l1t::Condition (name,
                      description,
                      locked)
  {
  }

  MuonCondition::
  MuonCondition (const MuonCondition& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::l1t::Condition (x, f, c)
  {
  }

  MuonCondition::
  MuonCondition (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::l1t::Condition (e, f, c)
  {
  }

  MuonCondition* MuonCondition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MuonCondition (*this, f, c);
  }

  MuonCondition::
  ~MuonCondition ()
  {
  }

  // EnergySumCondition
  //

  EnergySumCondition::
  EnergySumCondition (const name_type& name,
                      const description_type& description,
                      const locked_type& locked)
  : ::l1t::Condition (name,
                      description,
                      locked)
  {
  }

  EnergySumCondition::
  EnergySumCondition (const EnergySumCondition& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::l1t::Condition (x, f, c)
  {
  }

  EnergySumCondition::
  EnergySumCondition (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::l1t::Condition (e, f, c)
  {
  }

  EnergySumCondition* EnergySumCondition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class EnergySumCondition (*this, f, c);
  }

  EnergySumCondition::
  ~EnergySumCondition ()
  {
  }

  // CorrelationCondition
  //

  CorrelationCondition::
  CorrelationCondition (const name_type& name,
                        const description_type& description,
                        const locked_type& locked)
  : ::l1t::Condition (name,
                      description,
                      locked)
  {
  }

  CorrelationCondition::
  CorrelationCondition (const CorrelationCondition& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::l1t::Condition (x, f, c)
  {
  }

  CorrelationCondition::
  CorrelationCondition (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::l1t::Condition (e, f, c)
  {
  }

  CorrelationCondition* CorrelationCondition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CorrelationCondition (*this, f, c);
  }

  CorrelationCondition::
  ~CorrelationCondition ()
  {
  }

  // InvariantMassCondition
  //

  InvariantMassCondition::
  InvariantMassCondition (const name_type& name,
                          const description_type& description,
                          const locked_type& locked)
  : ::l1t::Condition (name,
                      description,
                      locked)
  {
  }

  InvariantMassCondition::
  InvariantMassCondition (const InvariantMassCondition& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::l1t::Condition (x, f, c)
  {
  }

  InvariantMassCondition::
  InvariantMassCondition (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::l1t::Condition (e, f, c)
  {
  }

  InvariantMassCondition* InvariantMassCondition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class InvariantMassCondition (*this, f, c);
  }

  InvariantMassCondition::
  ~InvariantMassCondition ()
  {
  }

  // DeltaRCondition
  //

  DeltaRCondition::
  DeltaRCondition (const name_type& name,
                   const description_type& description,
                   const locked_type& locked)
  : ::l1t::Condition (name,
                      description,
                      locked)
  {
  }

  DeltaRCondition::
  DeltaRCondition (const DeltaRCondition& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::l1t::Condition (x, f, c)
  {
  }

  DeltaRCondition::
  DeltaRCondition (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::l1t::Condition (e, f, c)
  {
  }

  DeltaRCondition* DeltaRCondition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DeltaRCondition (*this, f, c);
  }

  DeltaRCondition::
  ~DeltaRCondition ()
  {
  }

  // Algorithm
  //

  Algorithm::
  Algorithm (const name_type& name,
             const index_type& index,
             const equation_type& equation,
             const description_type& description,
             const locked_type& locked)
  : ::xml_schema::type (),
    name_ (name, ::xml_schema::flags (), this),
    index_ (index, ::xml_schema::flags (), this),
    equation_ (equation, ::xml_schema::flags (), this),
    description_ (description, ::xml_schema::flags (), this),
    locked_ (locked, ::xml_schema::flags (), this)
  {
  }

  Algorithm::
  Algorithm (const Algorithm& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    name_ (x.name_, f, this),
    index_ (x.index_, f, this),
    equation_ (x.equation_, f, this),
    description_ (x.description_, f, this),
    locked_ (x.locked_, f, this)
  {
  }

  Algorithm::
  Algorithm (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    name_ (f, this),
    index_ (f, this),
    equation_ (f, this),
    description_ (f, this),
    locked_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void Algorithm::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        if (!name_.present ())
        {
          this->name_.set (r);
          continue;
        }
      }

      // index
      //
      if (n.name () == "index" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< index_type > r (
          index_traits::create (i, f, this));

        if (!index_.present ())
        {
          this->index_.set (r);
          continue;
        }
      }

      // equation
      //
      if (n.name () == "equation" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< equation_type > r (
          equation_traits::create (i, f, this));

        if (!equation_.present ())
        {
          this->equation_.set (r);
          continue;
        }
      }

      // description
      //
      if (n.name () == "description" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< description_type > r (
          description_traits::create (i, f, this));

        if (!description_.present ())
        {
          this->description_.set (r);
          continue;
        }
      }

      // locked
      //
      if (n.name () == "locked" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        if (!locked_.present ())
        {
          this->locked_.set (locked_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "name",
        "http://www.cern.ch/l1t");
    }

    if (!index_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "index",
        "http://www.cern.ch/l1t");
    }

    if (!equation_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "equation",
        "http://www.cern.ch/l1t");
    }

    if (!description_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "description",
        "http://www.cern.ch/l1t");
    }

    if (!locked_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "locked",
        "http://www.cern.ch/l1t");
    }
  }

  Algorithm* Algorithm::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Algorithm (*this, f, c);
  }

  Algorithm::
  ~Algorithm ()
  {
  }

  // AlgorithmList
  //

  AlgorithmList::
  AlgorithmList ()
  : ::xml_schema::type (),
    algorithm_ (::xml_schema::flags (), this)
  {
  }

  AlgorithmList::
  AlgorithmList (const AlgorithmList& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    algorithm_ (x.algorithm_, f, this)
  {
  }

  AlgorithmList::
  AlgorithmList (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    algorithm_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void AlgorithmList::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // algorithm
      //
      if (n.name () == "algorithm" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< algorithm_type > r (
          algorithm_traits::create (i, f, this));

        this->algorithm_.push_back (r);
        continue;
      }

      break;
    }
  }

  AlgorithmList* AlgorithmList::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AlgorithmList (*this, f, c);
  }

  AlgorithmList::
  ~AlgorithmList ()
  {
  }

  // L1TriggerMenu
  //

  const L1TriggerMenu::version_type L1TriggerMenu::version_default_value_ (
    "0.4");

  L1TriggerMenu::
  L1TriggerMenu (const meta_type& meta,
                 const conditions_type& conditions,
                 const algorithms_type& algorithms)
  : ::xml_schema::type (),
    meta_ (meta, ::xml_schema::flags (), this),
    conditions_ (conditions, ::xml_schema::flags (), this),
    algorithms_ (algorithms, ::xml_schema::flags (), this),
    version_ (version_default_value (), ::xml_schema::flags (), this)
  {
  }

  L1TriggerMenu::
  L1TriggerMenu (::std::auto_ptr< meta_type >& meta,
                 ::std::auto_ptr< conditions_type >& conditions,
                 ::std::auto_ptr< algorithms_type >& algorithms)
  : ::xml_schema::type (),
    meta_ (meta, ::xml_schema::flags (), this),
    conditions_ (conditions, ::xml_schema::flags (), this),
    algorithms_ (algorithms, ::xml_schema::flags (), this),
    version_ (version_default_value (), ::xml_schema::flags (), this)
  {
  }

  L1TriggerMenu::
  L1TriggerMenu (const L1TriggerMenu& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    meta_ (x.meta_, f, this),
    conditions_ (x.conditions_, f, this),
    algorithms_ (x.algorithms_, f, this),
    version_ (x.version_, f, this)
  {
  }

  L1TriggerMenu::
  L1TriggerMenu (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    meta_ (f, this),
    conditions_ (f, this),
    algorithms_ (f, this),
    version_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void L1TriggerMenu::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // meta
      //
      if (n.name () == "meta" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< meta_type > r (
          meta_traits::create (i, f, this));

        if (!meta_.present ())
        {
          this->meta_.set (r);
          continue;
        }
      }

      // conditions
      //
      if (n.name () == "conditions" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< conditions_type > r (
          conditions_traits::create (i, f, this));

        if (!conditions_.present ())
        {
          this->conditions_.set (r);
          continue;
        }
      }

      // algorithms
      //
      if (n.name () == "algorithms" && n.namespace_ () == "http://www.cern.ch/l1t")
      {
        ::std::auto_ptr< algorithms_type > r (
          algorithms_traits::create (i, f, this));

        if (!algorithms_.present ())
        {
          this->algorithms_.set (r);
          continue;
        }
      }

      break;
    }

    if (!meta_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "meta",
        "http://www.cern.ch/l1t");
    }

    if (!conditions_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "conditions",
        "http://www.cern.ch/l1t");
    }

    if (!algorithms_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "algorithms",
        "http://www.cern.ch/l1t");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "version" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< version_type > r (
          version_traits::create (i, f, this));

        this->version_.set (r);
        continue;
      }
    }

    if (!version_.present ())
    {
      this->version_.set (version_default_value ());
    }
  }

  L1TriggerMenu* L1TriggerMenu::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class L1TriggerMenu (*this, f, c);
  }

  L1TriggerMenu::
  ~L1TriggerMenu ()
  {
  }
}

#include <istream>
#include <L1Trigger/L1TGlobal/src/L1TMenuEditor/xsd/cxx/xml/sax/std-input-source.hxx>
#include <L1Trigger/L1TGlobal/src/L1TMenuEditor/xsd/cxx/tree/error-handler.hxx>

namespace l1t
{
  ::std::auto_ptr< ::l1t::L1TriggerMenu >
  l1TriggerMenu (const ::std::string& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::l1t::L1TriggerMenu > r (
      ::l1t::l1TriggerMenu (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::l1t::L1TriggerMenu >
  l1TriggerMenu (const ::std::string& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::l1t::L1TriggerMenu > r (
      ::l1t::l1TriggerMenu (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::l1t::L1TriggerMenu >
  l1TriggerMenu (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::l1t::L1TriggerMenu > r (
      ::l1t::l1TriggerMenu (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::l1t::L1TriggerMenu >
  l1TriggerMenu (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::l1t::l1TriggerMenu (isrc, f, p);
  }

  ::std::auto_ptr< ::l1t::L1TriggerMenu >
  l1TriggerMenu (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::l1t::l1TriggerMenu (isrc, h, f, p);
  }

  ::std::auto_ptr< ::l1t::L1TriggerMenu >
  l1TriggerMenu (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::l1t::l1TriggerMenu (isrc, h, f, p);
  }

  ::std::auto_ptr< ::l1t::L1TriggerMenu >
  l1TriggerMenu (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::l1t::l1TriggerMenu (isrc, f, p);
  }

  ::std::auto_ptr< ::l1t::L1TriggerMenu >
  l1TriggerMenu (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::l1t::l1TriggerMenu (isrc, h, f, p);
  }

  ::std::auto_ptr< ::l1t::L1TriggerMenu >
  l1TriggerMenu (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::l1t::l1TriggerMenu (isrc, h, f, p);
  }

  ::std::auto_ptr< ::l1t::L1TriggerMenu >
  l1TriggerMenu (::xercesc::InputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::l1t::L1TriggerMenu > r (
      ::l1t::l1TriggerMenu (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::l1t::L1TriggerMenu >
  l1TriggerMenu (::xercesc::InputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::l1t::L1TriggerMenu > r (
      ::l1t::l1TriggerMenu (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::l1t::L1TriggerMenu >
  l1TriggerMenu (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::l1t::L1TriggerMenu > r (
      ::l1t::l1TriggerMenu (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::l1t::L1TriggerMenu >
  l1TriggerMenu (const ::xercesc::DOMDocument& d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::l1t::L1TriggerMenu > r (
        ::l1t::l1TriggerMenu (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "l1TriggerMenu" &&
        n.namespace_ () == "http://www.cern.ch/l1t")
    {
      ::std::auto_ptr< ::l1t::L1TriggerMenu > r (
        ::xsd::cxx::tree::traits< ::l1t::L1TriggerMenu, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "l1TriggerMenu",
      "http://www.cern.ch/l1t");
  }

  ::std::auto_ptr< ::l1t::L1TriggerMenu >
  l1TriggerMenu (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "l1TriggerMenu" &&
        n.namespace_ () == "http://www.cern.ch/l1t")
    {
      ::std::auto_ptr< ::l1t::L1TriggerMenu > r (
        ::xsd::cxx::tree::traits< ::l1t::L1TriggerMenu, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "l1TriggerMenu",
      "http://www.cern.ch/l1t");
  }
}

#include <L1Trigger/L1TGlobal/src/L1TMenuEditor/xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

