

class CircleJet8x8
{
  public:
    typedef uint32_t PodType;

    CircleJet8x8( ) : Energy ( 0 ) , E ( 0 ) , H ( 0 ) , Phi ( 0 ) {}

    CircleJet8x8 ( const std::vector< const TriggerTower* > & aTTs ) :
      Energy ( 0 ) , E ( 0 ) , H ( 0 ) , Phi ( 0 )
    {
      for( std::vector< const TriggerTower* >::const_iterator lIt = aTTs.begin(); lIt != aTTs.end(); ++lIt )
      {
        Energy += (**lIt).Energy;
        E += (**lIt).Ecal();
        H += (**lIt).Hcal();
      }
  
    }

    operator PodType () const
    {
      // q(i).data <= "00000000000000" & SortListOut0(i).value.Energy(10 downto 0 ) & std_logic_vector(to_unsigned( SortListOut0(i).initial_index , 7 ) );
      PodType lTemp ( 0 );
      lTemp |= PodType ( Energy & 0x1FFFF ) << 7;
      lTemp |= PodType ( Phi & 0x07F );
      return lTemp;
    }

    CircleJet8x8 ( const PodType& aPOD ) :  Energy ( 0 ) , E ( 0 ) , H ( 0 ) , Phi ( 0 )
    {
      Energy = ( aPOD >> 7 ) & 0x1FFFF;
      Phi    = ( aPOD >> 0 ) & 0x07F;
    }

    uint32_t Energy;
    uint32_t E;
    uint32_t H;

    //Only Set After Sort
    uint32_t Phi;
};

bool operator> ( const CircleJet8x8& aLeft , const CircleJet8x8& aRight )
{
  return ( aLeft.Energy > aRight.Energy );
}


bool map[8][8] = {
                  { 0,0,1,1,1,1,0,0 },
                  { 0,1,1,1,1,1,1,0 },
                  { 1,1,1,1,1,1,1,1 },
                  { 1,1,1,1,1,1,1,1 },
                  { 1,1,1,1,1,1,1,1 },
                  { 1,1,1,1,1,1,1,1 },
                  { 0,1,1,1,1,1,1,0 },
                  { 0,0,1,1,1,1,0,0 }
                };

Events< CircleJet8x8 > CreateCircleJet8x8s ( const Events< TriggerTower >& aTriggerTowerEvents )
{
  Events< CircleJet8x8 > lCircleJet8x8Events;

  for ( std::vector< ObjectsInEtaPhi<TriggerTower> >::const_iterator lIt = aTriggerTowerEvents.begin() ; lIt != aTriggerTowerEvents.event.end() ; ++lIt )
  {
    ObjectsInEtaPhi<CircleJet8x8> lCircleJet8x8s;

    for ( uint32_t lAbsEta = 0 ; lAbsEta != 27 ; ++lAbsEta )
    {
      for ( uint32_t lEtaHalf = 0 ; lEtaHalf != 2 ; ++lEtaHalf )
      {
        for ( uint32_t lPhi = 0 ; lPhi != 72 ; ++lPhi )
        {

          std::vector< const TriggerTower* > lJetTowers;
          lJetTowers.reserve(64);
          for( int32_t lDEta = -4; lDEta != 4; ++lDEta )
          {
            for( uint32_t lDPhi = 0; lDPhi != 8; ++lDPhi )
            {

              if( map[lDEta+4][lDPhi] )
              {
                int32_t lEtaX( int32_t(lAbsEta)+lDEta );
                int32_t lPhiX( ( lPhi+lDPhi )%72 );

                if( lEtaX >= 0 )
                {
                  const TriggerTower& a ( lIt->absEta[ lEtaX ].etaHalf[ lEtaHalf ].phi[ lPhiX ] );
                  lJetTowers.push_back( &a );
                }
                else
                {
                  const TriggerTower& a ( lIt->absEta[ -lEtaX-1 ].etaHalf[ 1-lEtaHalf ].phi[ lPhiX ] );
                  lJetTowers.push_back( &a );
                }
               }
            }
          }
          
          lCircleJet8x8s.absEta[ lAbsEta ].etaHalf[ lEtaHalf ].phi[ lPhi ] = CircleJet8x8 ( lJetTowers );

//           if ( lAbsEta == 0 )
//           {
//             const TriggerTower& a ( lIt->absEta[ 0 ].etaHalf[ 0 ].phi[ lPhi ] );
//             const TriggerTower& b ( lIt->absEta[ 0 ].etaHalf[ 0 ].phi[ ( lPhi+1 ) %72 ] );
//             const TriggerTower& c ( lIt->absEta[ 0 ].etaHalf[ 1 ].phi[ lPhi ] );
//             const TriggerTower& d ( lIt->absEta[ 0 ].etaHalf[ 1 ].phi[ ( lPhi+1 ) %72 ] );
//             lCircleJet8x8s.absEta[ lAbsEta ].etaHalf[ lEtaHalf ].phi[ lPhi ] = CircleJet8x8 ( a , b , c , d );
//           }
//           else
//           {
//             const TriggerTower& a ( lIt->absEta[ lAbsEta ].etaHalf[ lEtaHalf ].phi[ lPhi ] );
//             const TriggerTower& b ( lIt->absEta[ lAbsEta ].etaHalf[ lEtaHalf ].phi[ ( lPhi+1 ) %72 ] );
//             const TriggerTower& c ( lIt->absEta[ lAbsEta-1 ].etaHalf[ lEtaHalf ].phi[ lPhi ] );
//             const TriggerTower& d ( lIt->absEta[ lAbsEta-1 ].etaHalf[ lEtaHalf ].phi[ ( lPhi+1 ) %72 ] );
//             lCircleJet8x8s.absEta[ lAbsEta ].etaHalf[ lEtaHalf ].phi[ lPhi ] = CircleJet8x8 ( a , b , c , d );
//           }
        }
      }
    }

    lCircleJet8x8Events.event.push_back ( lCircleJet8x8s );
  }

  return lCircleJet8x8Events;
}


SortedEvents< CircleJet8x8 > 
Sorted ( Events< CircleJet8x8 >& aCircleJet8x8Events )
{
  SortedEvents< CircleJet8x8 > lCircleJet8x8SortedEvents;
  lCircleJet8x8SortedEvents.event.resize( aCircleJet8x8Events.event.size() );

  std::vector< ObjectsInEtaPhi<CircleJet8x8> >::iterator        lIt = aCircleJet8x8Events.event.begin();
  std::vector< SortedObjectsInEtaPhi<CircleJet8x8> >::iterator lIt2 = lCircleJet8x8SortedEvents.event.begin();

  for (  ; lIt != aCircleJet8x8Events.event.end() ; ++lIt, ++lIt2 )
  {
    for ( uint32_t lAbsEta = 0 ; lAbsEta != 30 ; ++lAbsEta )
    {
      for ( uint32_t lEtaHalf = 0 ; lEtaHalf != 2 ; ++lEtaHalf )
      {
        for ( uint32_t lPhi = 0 ; lPhi != 72 ; ++lPhi )
        {
          lIt->absEta[ lAbsEta ].etaHalf[ lEtaHalf ].phi[ lPhi ].Phi = lPhi;
        }      

        const CircleJet8x8*  lInputData( lIt->absEta[ lAbsEta ].etaHalf[ lEtaHalf ].phi );
              CircleJet8x8* lOutputData( lIt2->absEta[ lAbsEta ].etaHalf[ lEtaHalf ].index );

        CompactObjectBitonic4From72x( lInputData , lOutputData );

      }
    }

  }

  return lCircleJet8x8SortedEvents;
}